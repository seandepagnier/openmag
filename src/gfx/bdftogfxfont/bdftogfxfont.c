/* Copyright (C) 2007, 2008 Sean D'Epagnier <sean@depagnier.com>
 *
 * This Program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * For more information on the GPL, please go to:
 * http://www.gnu.org/copyleft/gpl.html
 */

#include <stdio.h>
#include <stdlib.h>

#include <stdint.h>

#include <string.h>

#include <gfx/gfx.h>
#include <gfx/font.h>

#define PRGNAME "bdftogfxfont"
#define STR(X) #X

#define die(FMT, ...) (fprintf(stderr, PRGNAME " line %d: " \
                               FMT, __LINE__, ## __VA_ARGS__), exit(1))

#define die_syntax die("syntax error\n");

char line[1024];

struct gfx_font *fonts;
int fontcount;

void addfontspace(void)
{
   fontcount++;
   if(!(fonts = realloc(fonts, sizeof *fonts * fontcount)))
      die("realloc failed\n");

   const static struct gfx_font defaultfont = {0};
   fonts[fontcount - 1] = defaultfont;
}

int grabbyte(char **buf, char *byte)
{
   char x[3] = {(*buf)[0], (*buf)[1], 0};
   if(sscanf(x, "%hhx", byte) == 1) {
      *buf += 2;
      return 1;
   }
   (*buf)++;
   return 0;
}

void read_bitmap(char *data, int width, int height)
{
   int i, j, pos = 0;

   char *l = line + 6;
   for(i = 0; i < height; i++)
      for(j = 0; j < BYTESW(width); j++) {
         while(!grabbyte(&l, data + pos)) {
            if(!fgets(line, sizeof line, stdin))
               die("unexpected eof\n");
            l = line;
         }
         pos++;
      }
}

/* takes one argument which is the number of input fonts that should
   have full character sets, any fonts after these only are numeric */
int main(int argc, char *argv[])
{
   int offtonumeric = 9999;
   if(argc == 2)
      offtonumeric = strtol(argv[1], NULL, 10);

   struct gfx_character *newchar = NULL;

   int curchar;
   for(;;) {
      struct gfx_font *f = fonts + fontcount - 1;

      int end = sizeof line - 1;
      line[end] = '\0';
      if(!fgets(line, sizeof line, stdin))
         break;

      if(line[end] && line[end] != '\n') {
         die("line longer than "STR(sizeof line)" aborting!\n");
         abort();
      }

      if(!strncmp("FONTBOUNDINGBOX ", line, 16))
         if(sscanf(line + 16, "%hhd %hhd\n",
                   &f->width, &f->height) != 2)
            die_syntax;

      if(!strncmp("FONT ", line, 5)){
         addfontspace();

         f = fonts + fontcount - 1;
      }

      if(!strncmp("STARTCHAR ", line, 10))
         newchar = malloc(sizeof(struct gfx_character));

      if(newchar) {
         if(!strncmp("ENCODING ", line, 9)) {
            if(sscanf(line + 9, "%d\n", &curchar) != 1)
               die_syntax;
            if(curchar < 32 || curchar > 127
               || (fontcount > offtonumeric
                   && ((curchar < '0' || curchar > '9') && curchar != '.'))) {
               free(newchar);
               newchar = NULL;
            }
         }

         if(!strncmp("BBX ", line, 4)) {
            if(sscanf(line + 4, "%hhd %hhd %hhd %hhd\n", &newchar->width,
                      &newchar->height, &newchar->xoff, &newchar->yoff) != 4)
               die_syntax;
            newchar = realloc(newchar, sizeof(struct gfx_character)
                              + BYTESW(newchar->width) * newchar->height);
         }

         if(!strncmp("DWIDTH ", line, 7))
            if(sscanf(line + 7, "%hhd", &newchar->dwidth) < 1)
               die_syntax;

         if(!strncmp("BITMAP", line, 6)) {
            read_bitmap(newchar->data, newchar->width, newchar->height);
            f->characters[curchar-32] = newchar;
            newchar = NULL;
         }
      }
   }

   /* print out the font data */
//   FILE *header = fopen("fonts.h", "w");
   FILE *header = stdout;

   fprintf(header, "/* this file generated by bdftogfxfont*/\n\n");

   int i, j, k, l;
   for(i = 0; i<fontcount; i++) {
      for(j = 0; j<96; j++) {
         const struct gfx_character *c = fonts[i].characters[j];
         if(c) {
            fprintf(header, "struct gfx_character character_%d_%d PROGMEM = {\n",
                    i, j);
            fprintf(header, " %d, %d,\n %d, %d,\n %d, \n",
                    c->width, c->height, c->xoff, c->yoff, c->dwidth, i, j);
            fprintf(header, "{\n",
                   i, j, BYTESW(c->width), c->height);
#define NO_COMPRESSION
#ifdef NO_COMPRESSION
            for(k = 0; k < c->height; k++) {
               for(l = 0; l < BYTESW(c->width); l++)
                  fprintf(header, "0x%hhx, ", c->data[k*BYTESW(c->width) + l]);
               fprintf(header, "\n");
            }
#else
            int curlen = 0, curbit = 0, curnibble = 1, highnibble;
            for(k = 0; k < c->height; k++)
               for(l = 0; l < c->width; l++) {
                  int bit = !!(c->data[k*BYTESW(c->width) + (l>>3)] & (1 << (7-(l&0x7))));
                  if(curlen == 0)
                     curbit = bit;
                  if(curbit != bit || ++curlen == 8) {
                     int nibble = (curbit << 4) | (curlen & 0x7);
                     if((curnibble = !curnibble))
                        fprintf(header, "0x%hhx, ", (highnibble << 4) | nibble);
                     else
                        highnibble = nibble;

                     curbit = bit;
                     curlen = 1;
                  }
               }
            fprintf(header, "\n");
#endif
            fprintf(header, "}\n");
            fprintf(header, "};\n\n");
         }
      }     
   }

   fprintf(header, "struct gfx_font gfx_fonts[%d] PROGMEM = {\n", fontcount);
   for(i = 0; i<fontcount; i++) {
      fprintf(header, "{ %d,\n %d, %d,\n{\n", fonts[i].size,
             fonts[i].width, fonts[i].height);
      for(j = 0; j<96; j++) {
         const struct gfx_character *c = fonts[i].characters[j];
         if(c)
            fprintf(header, "&character_%d_%d,\n", i, j);
         else
            fprintf(header, "0,\n");
      }
      fprintf(header, "}\n},\n");
   }
   fprintf(header, "};\n");
   return 0;
}
